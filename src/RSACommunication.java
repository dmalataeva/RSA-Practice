/**
 * Created by Deniza on 8/9/2016 for ECE103
 */


import java.math.BigInteger;
import java.util.Random;
import java.util.Scanner;


public class RSACommunication {

    public static final int bitLength = 1200; //Set specifically for a private key of length +600 digits
    public static final Random rnd = new Random();

    public static final String MESSAGE_TO_RECIPIENT = ""; //Removed due to security reasons
    public static BigInteger MESSAGE_FROM_RECIPIENT = new BigInteger(""); //Removed due to security reasons
    public static BigInteger RECIPIENT_KEY_N = new BigInteger(""); //Recipient's public modulus is placed here
    public static BigInteger RECIPIENT_KEY_E = new BigInteger(""); //Recipient's public exponent is placed here


    public static BigInteger MY_KEY_D = new BigInteger(""); //Removed due to security reasons
    public static BigInteger MY_KEY_N = new BigInteger(""); //Each key is generated by running the program
    public static BigInteger MY_KEY_E = new BigInteger(""); //User-picked prime number

    public static void main(String [] args){

        Scanner input = new Scanner(System.in);
        input.useDelimiter("\\n");
        BigInteger encryptedText,decryptedText,textAsInteger;
        textAsInteger = new BigInteger(MESSAGE_TO_RECIPIENT);
        int choice;

        while (true) {
            System.out.println("RSA Encryption for ECE103: \n Generate new RSA key (1)\n Use Deniza's key (2)\n Encrypt message to Martin Pei (3)\n Decrypt message from Martin Pei (4)");
            choice = Integer.parseInt(input.nextLine());

            if (choice == 1) {
                System.out.println("\n Enter your desired value for the public exponent:\n");
                BigInteger inputForE = new BigInteger(input.nextLine());
                if (!inputForE.isProbablePrime(100)) {
                    inputForE = inputForE.nextProbablePrime();
                }
                my_Key generatedKey = generateKey(inputForE);
                System.out.println("Your generated key:\nPublic exponent: " + generatedKey.e + "\nModulus: " + generatedKey.n + "\nPrivate exponent: " + generatedKey.d);
            } else if (choice == 2) {
                System.out.println(textAsInteger.toString());
                encryptedText = textAsInteger.modPow(MY_KEY_E, MY_KEY_N);
                System.out.println("Encrypted text:\n" + encryptedText.toString());
                System.out.println("Continue to decryption (Press Enter)");
                input.nextLine();
                decryptedText = encryptedText.modPow(MY_KEY_D, MY_KEY_N);
                System.out.println("Decrypted text: \n" + decryptedText.toString());
            } else if (choice == 3) {
                encryptedText = textAsInteger.modPow(RECIPIENT_KEY_E, RECIPIENT_KEY_N);
                System.out.println("Encrypted text:\n" + encryptedText.toString());
            } else if (choice == 4) {
                decryptedText = MESSAGE_FROM_RECIPIENT.modPow(MY_KEY_D,MY_KEY_N);
                System.out.println("Decrypted text:\n" + decryptedText.toString());
            }
            input.nextLine();
        }
    }


    public static my_Key generateKey(BigInteger e){
        BigInteger p,q,px,qx,nx,n,f,d;
        p = BigInteger.probablePrime(bitLength,rnd);
        q = p;

        while (p==q){
            q = BigInteger.probablePrime(bitLength,rnd);
        }

        n = p.multiply(q);
        px = p.subtract(BigInteger.ONE);
        qx = q.subtract(BigInteger.ONE);
        nx = px.multiply(qx);

        BigInteger k = BigInteger.ZERO;
        do{
            k = k.add(BigInteger.ONE);
            f = nx.multiply(k);
            f = f.add(BigInteger.ONE);
        } while (!f.remainder(e).equals(BigInteger.ZERO));

        d = f.divide(e);
        return (new my_Key(p,q,n,e,d));
    }
}
